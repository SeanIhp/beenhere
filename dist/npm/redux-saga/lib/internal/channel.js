"use strict";var exports=module.exports={};
var _assign = require('../../../babel-runtime/core-js/object/assign.js');

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UNDEFINED_INPUT_ERROR = exports.INVALID_BUFFER = exports.isEnd = exports.END = undefined;

var _extends = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

exports.emitter = emitter;
exports.channel = channel;
exports.eventChannel = eventChannel;
exports.stdChannel = stdChannel;

var _utils = require('./utils.js');

var _buffers = require('./buffers.js');

var CHANNEL_END_TYPE = '@@redux-saga/CHANNEL_END';
var END = exports.END = { type: CHANNEL_END_TYPE };
var isEnd = exports.isEnd = function isEnd(a) {
  return a && a.type === CHANNEL_END_TYPE;
};

function emitter() {
  var subscribers = [];

  function subscribe(sub) {
    subscribers.push(sub);
    return function () {
      return (0, _utils.remove)(subscribers, sub);
    };
  }

  function emit(item) {
    var arr = subscribers.slice();
    for (var i = 0, len = arr.length; i < len; i++) {
      arr[i](item);
    }
  }

  return {
    subscribe: subscribe,
    emit: emit
  };
}

var INVALID_BUFFER = exports.INVALID_BUFFER = 'invalid buffer passed to channel factory function';
var UNDEFINED_INPUT_ERROR = exports.UNDEFINED_INPUT_ERROR = 'Saga was provided with an undefined action';

if ("development" !== 'production') {
  exports.UNDEFINED_INPUT_ERROR = UNDEFINED_INPUT_ERROR += '\nHints:\n    - check that your Action Creator returns a non-undefined value\n    - if the Saga was started using runSaga, check that your subscribe source provides the action to its listeners\n  ';
}

function channel() {
  var buffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _buffers.buffers.fixed();

  var closed = false;
  var takers = [];

  (0, _utils.check)(buffer, _utils.is.buffer, INVALID_BUFFER);

  function checkForbiddenStates() {
    if (closed && takers.length) {
      throw (0, _utils.internalErr)('Cannot have a closed channel with pending takers');
    }
    if (takers.length && !buffer.isEmpty()) {
      throw (0, _utils.internalErr)('Cannot have pending takers with non empty buffer');
    }
  }

  function put(input) {
    checkForbiddenStates();
    (0, _utils.check)(input, _utils.is.notUndef, UNDEFINED_INPUT_ERROR);
    if (closed) {
      return;
    }
    if (!takers.length) {
      return buffer.put(input);
    }
    for (var i = 0; i < takers.length; i++) {
      var cb = takers[i];
      if (!cb[_utils.MATCH] || cb[_utils.MATCH](input)) {
        takers.splice(i, 1);
        return cb(input);
      }
    }
  }

  function take(cb) {
    checkForbiddenStates();
    (0, _utils.check)(cb, _utils.is.func, 'channel.take\'s callback must be a function');

    if (closed && buffer.isEmpty()) {
      cb(END);
    } else if (!buffer.isEmpty()) {
      cb(buffer.take());
    } else {
      takers.push(cb);
      cb.cancel = function () {
        return (0, _utils.remove)(takers, cb);
      };
    }
  }

  function flush(cb) {
    checkForbiddenStates(); // TODO: check if some new state should be forbidden now
    (0, _utils.check)(cb, _utils.is.func, 'channel.flush\' callback must be a function');
    if (closed && buffer.isEmpty()) {
      cb(END);
      return;
    }
    cb(buffer.flush());
  }

  function close() {
    checkForbiddenStates();
    if (!closed) {
      closed = true;
      if (takers.length) {
        var arr = takers;
        takers = [];
        for (var i = 0, len = arr.length; i < len; i++) {
          arr[i](END);
        }
      }
    }
  }

  return { take: take, put: put, flush: flush, close: close,
    get __takers__() {
      return takers;
    },
    get __closed__() {
      return closed;
    }
  };
}

function eventChannel(subscribe) {
  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _buffers.buffers.none();
  var matcher = arguments[2];

  /**
    should be if(typeof matcher !== undefined) instead?
    see PR #273 for a background discussion
  **/
  if (arguments.length > 2) {
    (0, _utils.check)(matcher, _utils.is.func, 'Invalid match function passed to eventChannel');
  }

  var chan = channel(buffer);
  var unsubscribe = subscribe(function (input) {
    if (isEnd(input)) {
      chan.close();
    } else if (!matcher || matcher(input)) {
      chan.put(input);
    }
  });

  if (!_utils.is.func(unsubscribe)) {
    throw new Error('in eventChannel: subscribe should return a function to unsubscribe');
  }

  return {
    take: chan.take,
    flush: chan.flush,
    close: function close() {
      if (!chan.__closed__) {
        chan.close();
        unsubscribe();
      }
    }
  };
}

function stdChannel(subscribe) {
  var chan = eventChannel(subscribe);

  return _extends({}, chan, {
    take: function take(cb, matcher) {
      if (arguments.length > 1) {
        (0, _utils.check)(matcher, _utils.is.func, 'channel.take\'s matcher argument must be a function');
        cb[_utils.MATCH] = matcher;
      }
      chan.take(cb);
    }
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNoYW5uZWwuanMiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJVTkRFRklORURfSU5QVVRfRVJST1IiLCJJTlZBTElEX0JVRkZFUiIsImlzRW5kIiwiRU5EIiwidW5kZWZpbmVkIiwiX2V4dGVuZHMiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZW1pdHRlciIsImNoYW5uZWwiLCJldmVudENoYW5uZWwiLCJzdGRDaGFubmVsIiwiX3V0aWxzIiwicmVxdWlyZSIsIl9idWZmZXJzIiwiQ0hBTk5FTF9FTkRfVFlQRSIsInR5cGUiLCJhIiwic3Vic2NyaWJlcnMiLCJzdWJzY3JpYmUiLCJzdWIiLCJwdXNoIiwicmVtb3ZlIiwiZW1pdCIsIml0ZW0iLCJhcnIiLCJzbGljZSIsImxlbiIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImJ1ZmZlciIsImJ1ZmZlcnMiLCJmaXhlZCIsImNsb3NlZCIsInRha2VycyIsImNoZWNrIiwiaXMiLCJjaGVja0ZvcmJpZGRlblN0YXRlcyIsImludGVybmFsRXJyIiwiaXNFbXB0eSIsInB1dCIsImlucHV0Iiwibm90VW5kZWYiLCJjYiIsIk1BVENIIiwic3BsaWNlIiwidGFrZSIsImZ1bmMiLCJjYW5jZWwiLCJmbHVzaCIsImNsb3NlIiwiX190YWtlcnNfXyIsIl9fY2xvc2VkX18iLCJub25lIiwibWF0Y2hlciIsImNoYW4iLCJ1bnN1YnNjcmliZSIsIkVycm9yIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFFQUEsT0FBT0MsY0FBUCxDQUFzQkMsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFDM0NDLFNBQU87QUFEb0MsQ0FBN0M7QUFHQUQsUUFBUUUscUJBQVIsR0FBZ0NGLFFBQVFHLGNBQVIsR0FBeUJILFFBQVFJLEtBQVIsR0FBZ0JKLFFBQVFLLEdB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VCxDQUFvQlEsU0FBcEIsRUFBK0I7QUFDN0IsTUFBSXFDLE9BQU85QyxhQUFhUyxTQUFiLENBQVg7O0FBRUEsU0FBT3JCLFNBQVMsRUFBVCxFQUFhMEQsSUFBYixFQUFtQjtBQUN4QlQsVUFBTSxTQUFTQSxJQUFULENBQWNILEVBQWQsRUFBa0JXLE9BQWxCLEVBQTJCO0FBQy9CLFVBQUl0RCxVQUFVQyxNQUFWLEdBQW1CLENBQXZCLEVBQTBCO0FBQ3hCLFNBQUMsR0FBR1UsT0FBT3dCLEtBQVgsRUFBa0JtQixPQUFsQixFQUEyQjNDLE9BQU95QixFQUFQLENBQVVXLElBQXJDLEVBQTJDLHFEQUEzQztBQUNBSixXQUFHaEMsT0FBT2lDLEtBQVYsSUFBbUJVLE9BQW5CO0FBQ0Q7QUFDREMsV0FBS1QsSUFBTCxDQUFVSCxFQUFWO0FBQ0Q7QUFQdUIsR0FBbkIsQ0FBUDtBQVNEIiwiZmlsZSI6InVua25vd24iLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlVOREVGSU5FRF9JTlBVVF9FUlJPUiA9IGV4cG9ydHMuSU5WQUxJRF9CVUZGRVIgPSBleHBvcnRzLmlzRW5kID0gZXhwb3J0cy5FTkQgPSB1bmRlZmluZWQ7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZW1pdHRlciA9IGVtaXR0ZXI7XG5leHBvcnRzLmNoYW5uZWwgPSBjaGFubmVsO1xuZXhwb3J0cy5ldmVudENoYW5uZWwgPSBldmVudENoYW5uZWw7XG5leHBvcnRzLnN0ZENoYW5uZWwgPSBzdGRDaGFubmVsO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgX2J1ZmZlcnMgPSByZXF1aXJlKCcuL2J1ZmZlcnMnKTtcblxudmFyIENIQU5ORUxfRU5EX1RZUEUgPSAnQEByZWR1eC1zYWdhL0NIQU5ORUxfRU5EJztcbnZhciBFTkQgPSBleHBvcnRzLkVORCA9IHsgdHlwZTogQ0hBTk5FTF9FTkRfVFlQRSB9O1xudmFyIGlzRW5kID0gZXhwb3J0cy5pc0VuZCA9IGZ1bmN0aW9uIGlzRW5kKGEpIHtcbiAgcmV0dXJuIGEgJiYgYS50eXBlID09PSBDSEFOTkVMX0VORF9UWVBFO1xufTtcblxuZnVuY3Rpb24gZW1pdHRlcigpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gW107XG5cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKHN1Yikge1xuICAgIHN1YnNjcmliZXJzLnB1c2goc3ViKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICgwLCBfdXRpbHMucmVtb3ZlKShzdWJzY3JpYmVycywgc3ViKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZW1pdChpdGVtKSB7XG4gICAgdmFyIGFyciA9IHN1YnNjcmliZXJzLnNsaWNlKCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJyW2ldKGl0ZW0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZW1pdDogZW1pdFxuICB9O1xufVxuXG52YXIgSU5WQUxJRF9CVUZGRVIgPSBleHBvcnRzLklOVkFMSURfQlVGRkVSID0gJ2ludmFsaWQgYnVmZmVyIHBhc3NlZCB0byBjaGFubmVsIGZhY3RvcnkgZnVuY3Rpb24nO1xudmFyIFVOREVGSU5FRF9JTlBVVF9FUlJPUiA9IGV4cG9ydHMuVU5ERUZJTkVEX0lOUFVUX0VSUk9SID0gJ1NhZ2Egd2FzIHByb3ZpZGVkIHdpdGggYW4gdW5kZWZpbmVkIGFjdGlvbic7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGV4cG9ydHMuVU5ERUZJTkVEX0lOUFVUX0VSUk9SID0gVU5ERUZJTkVEX0lOUFVUX0VSUk9SICs9ICdcXG5IaW50czpcXG4gICAgLSBjaGVjayB0aGF0IHlvdXIgQWN0aW9uIENyZWF0b3IgcmV0dXJucyBhIG5vbi11bmRlZmluZWQgdmFsdWVcXG4gICAgLSBpZiB0aGUgU2FnYSB3YXMgc3RhcnRlZCB1c2luZyBydW5TYWdhLCBjaGVjayB0aGF0IHlvdXIgc3Vic2NyaWJlIHNvdXJjZSBwcm92aWRlcyB0aGUgYWN0aW9uIHRvIGl0cyBsaXN0ZW5lcnNcXG4gICc7XG59XG5cbmZ1bmN0aW9uIGNoYW5uZWwoKSB7XG4gIHZhciBidWZmZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF9idWZmZXJzLmJ1ZmZlcnMuZml4ZWQoKTtcblxuICB2YXIgY2xvc2VkID0gZmFsc2U7XG4gIHZhciB0YWtlcnMgPSBbXTtcblxuICAoMCwgX3V0aWxzLmNoZWNrKShidWZmZXIsIF91dGlscy5pcy5idWZmZXIsIElOVkFMSURfQlVGRkVSKTtcblxuICBmdW5jdGlvbiBjaGVja0ZvcmJpZGRlblN0YXRlcygpIHtcbiAgICBpZiAoY2xvc2VkICYmIHRha2Vycy5sZW5ndGgpIHtcbiAgICAgIHRocm93ICgwLCBfdXRpbHMuaW50ZXJuYWxFcnIpKCdDYW5ub3QgaGF2ZSBhIGNsb3NlZCBjaGFubmVsIHdpdGggcGVuZGluZyB0YWtlcnMnKTtcbiAgICB9XG4gICAgaWYgKHRha2Vycy5sZW5ndGggJiYgIWJ1ZmZlci5pc0VtcHR5KCkpIHtcbiAgICAgIHRocm93ICgwLCBfdXRpbHMuaW50ZXJuYWxFcnIpKCdDYW5ub3QgaGF2ZSBwZW5kaW5nIHRha2VycyB3aXRoIG5vbiBlbXB0eSBidWZmZXInKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwdXQoaW5wdXQpIHtcbiAgICBjaGVja0ZvcmJpZGRlblN0YXRlcygpO1xuICAgICgwLCBfdXRpbHMuY2hlY2spKGlucHV0LCBfdXRpbHMuaXMubm90VW5kZWYsIFVOREVGSU5FRF9JTlBVVF9FUlJPUik7XG4gICAgaWYgKGNsb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRha2Vycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBidWZmZXIucHV0KGlucHV0KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWtlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjYiA9IHRha2Vyc1tpXTtcbiAgICAgIGlmICghY2JbX3V0aWxzLk1BVENIXSB8fCBjYltfdXRpbHMuTUFUQ0hdKGlucHV0KSkge1xuICAgICAgICB0YWtlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICByZXR1cm4gY2IoaW5wdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRha2UoY2IpIHtcbiAgICBjaGVja0ZvcmJpZGRlblN0YXRlcygpO1xuICAgICgwLCBfdXRpbHMuY2hlY2spKGNiLCBfdXRpbHMuaXMuZnVuYywgJ2NoYW5uZWwudGFrZVxcJ3MgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICBpZiAoY2xvc2VkICYmIGJ1ZmZlci5pc0VtcHR5KCkpIHtcbiAgICAgIGNiKEVORCk7XG4gICAgfSBlbHNlIGlmICghYnVmZmVyLmlzRW1wdHkoKSkge1xuICAgICAgY2IoYnVmZmVyLnRha2UoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRha2Vycy5wdXNoKGNiKTtcbiAgICAgIGNiLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMucmVtb3ZlKSh0YWtlcnMsIGNiKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goY2IpIHtcbiAgICBjaGVja0ZvcmJpZGRlblN0YXRlcygpOyAvLyBUT0RPOiBjaGVjayBpZiBzb21lIG5ldyBzdGF0ZSBzaG91bGQgYmUgZm9yYmlkZGVuIG5vd1xuICAgICgwLCBfdXRpbHMuY2hlY2spKGNiLCBfdXRpbHMuaXMuZnVuYywgJ2NoYW5uZWwuZmx1c2hcXCcgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgaWYgKGNsb3NlZCAmJiBidWZmZXIuaXNFbXB0eSgpKSB7XG4gICAgICBjYihFTkQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYihidWZmZXIuZmx1c2goKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBjaGVja0ZvcmJpZGRlblN0YXRlcygpO1xuICAgIGlmICghY2xvc2VkKSB7XG4gICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgaWYgKHRha2Vycy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGFyciA9IHRha2VycztcbiAgICAgICAgdGFrZXJzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBhcnJbaV0oRU5EKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IHRha2U6IHRha2UsIHB1dDogcHV0LCBmbHVzaDogZmx1c2gsIGNsb3NlOiBjbG9zZSxcbiAgICBnZXQgX190YWtlcnNfXygpIHtcbiAgICAgIHJldHVybiB0YWtlcnM7XG4gICAgfSxcbiAgICBnZXQgX19jbG9zZWRfXygpIHtcbiAgICAgIHJldHVybiBjbG9zZWQ7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBldmVudENoYW5uZWwoc3Vic2NyaWJlKSB7XG4gIHZhciBidWZmZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IF9idWZmZXJzLmJ1ZmZlcnMubm9uZSgpO1xuICB2YXIgbWF0Y2hlciA9IGFyZ3VtZW50c1syXTtcblxuICAvKipcclxuICAgIHNob3VsZCBiZSBpZih0eXBlb2YgbWF0Y2hlciAhPT0gdW5kZWZpbmVkKSBpbnN0ZWFkP1xyXG4gICAgc2VlIFBSICMyNzMgZm9yIGEgYmFja2dyb3VuZCBkaXNjdXNzaW9uXHJcbiAgKiovXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICgwLCBfdXRpbHMuY2hlY2spKG1hdGNoZXIsIF91dGlscy5pcy5mdW5jLCAnSW52YWxpZCBtYXRjaCBmdW5jdGlvbiBwYXNzZWQgdG8gZXZlbnRDaGFubmVsJyk7XG4gIH1cblxuICB2YXIgY2hhbiA9IGNoYW5uZWwoYnVmZmVyKTtcbiAgdmFyIHVuc3Vic2NyaWJlID0gc3Vic2NyaWJlKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmIChpc0VuZChpbnB1dCkpIHtcbiAgICAgIGNoYW4uY2xvc2UoKTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaGVyIHx8IG1hdGNoZXIoaW5wdXQpKSB7XG4gICAgICBjaGFuLnB1dChpbnB1dCk7XG4gICAgfVxuICB9KTtcblxuICBpZiAoIV91dGlscy5pcy5mdW5jKHVuc3Vic2NyaWJlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW4gZXZlbnRDaGFubmVsOiBzdWJzY3JpYmUgc2hvdWxkIHJldHVybiBhIGZ1bmN0aW9uIHRvIHVuc3Vic2NyaWJlJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRha2U6IGNoYW4udGFrZSxcbiAgICBmbHVzaDogY2hhbi5mbHVzaCxcbiAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoIWNoYW4uX19jbG9zZWRfXykge1xuICAgICAgICBjaGFuLmNsb3NlKCk7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBzdGRDaGFubmVsKHN1YnNjcmliZSkge1xuICB2YXIgY2hhbiA9IGV2ZW50Q2hhbm5lbChzdWJzY3JpYmUpO1xuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgY2hhbiwge1xuICAgIHRha2U6IGZ1bmN0aW9uIHRha2UoY2IsIG1hdGNoZXIpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAoMCwgX3V0aWxzLmNoZWNrKShtYXRjaGVyLCBfdXRpbHMuaXMuZnVuYywgJ2NoYW5uZWwudGFrZVxcJ3MgbWF0Y2hlciBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgY2JbX3V0aWxzLk1BVENIXSA9IG1hdGNoZXI7XG4gICAgICB9XG4gICAgICBjaGFuLnRha2UoY2IpO1xuICAgIH1cbiAgfSk7XG59Il19